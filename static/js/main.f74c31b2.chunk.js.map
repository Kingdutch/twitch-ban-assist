{"version":3,"sources":["serviceWorker.js","config.js","auth/index.js","screens/Anonymous.js","api/index.js","components/BanForm.js","chat/index.js","screens/Authenticated.js","Router.js","components/Footer.js","App.js","index.js"],"names":["Boolean","window","location","hostname","match","unregister","navigator","serviceWorker","ready","then","registration","catch","error","console","message","client_id","scope","useAuthState","useQuery","getAccessToken","isLoadingToken","isLoading","isErrorToken","isError","token","data","errorToken","validateToken","enabled","useUserId","isLoadingId","isErrorId","user","errorId","a","localStorage","getItem","getAccessTokenFromUrl","setItem","removeItem","force","validation_time","parseInt","user_id","user_name","Date","now","fetch","headers","Authorization","response","ok","json","toString","hash","length","queryString","query","pairs","substr","split","i","j","pair","decodeURIComponent","parseQuery","Anonymous","authLink","encodeURIComponent","join","className","href","twitchApi","endpoint","access_token","url","URL","search","URLSearchParams","result","status","toChannel","str","channel","toLowerCase","BanForm","chatClient","follows","useState","reduce","f","to_name","selected","updateSelected","isMod","updateMod","useEffect","onJoin","joinedUser","weAreMod","modStatus","on","off","target_user","reason","banForm","updateBanForm","banState","updateBanState","allSelected","Object","entries","filter","k","every","mod_channel_list","follower","follower_list","map","key","to_id","type","value","checked","onChange","fromEntries","colSpan","required","e","target","s","disabled","onClick","channelsToBanIn","ban","keys","client","getChatClient","channels","clientStateUpdate","Client","options","debug","process","connection","reconnect","secure","identity","username","password","logger","info","warn","createChatClient","connect","Authenticated","from_id","staleTime","followed_at","from_name","useFollows","chatError","updateChatState","clientCleanup","useRef","current","disconnect","loggedInAs","Router","Footer","App","queryCache","QueryCache","setMaxListeners","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.f74c31b2.chunk.js","sourcesContent":["// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","export const client_id = \"ok7ldffjfrdafeme3x5jfob7rxhmlv\";\nexport const redirect_uri = process.env.NODE_ENV === \"production\" ? \"https://kingdutch.github.io/twitch-ban-assist/\" : \"http://localhost:3000/twitch-ban-assist/\";\nexport const scope = [\n  'chat:read',\n  'chat:edit',\n  'channel:moderate',\n];\n","import { useQuery } from 'react-query';\nimport { client_id, redirect_uri, scope } from '../config';\n\n/**\n * React hook to get the auth state for a user.\n *\n * @return {{isLoading: boolean, isError: boolean, data: {user_id: string,\n *   token: string}, error: unknown}}\n */\nexport function useAuthState() {\n  const { isLoading: isLoadingToken, isError: isErrorToken, data: token, error: errorToken } = useAccessToken();\n  const { isLoading: isLoadingId, isError: isErrorId, data: user, error: errorId } = useUserId(token);\n  return {\n    isLoading: isLoadingToken || isLoadingId,\n    isError: isErrorToken || isErrorId,\n    data: { token, user: typeof user === \"undefined\" ? null : user },\n    error: errorToken || errorId,\n  };\n}\n\n/**\n * React hook to get the access token using react-query.\n */\nexport function useAccessToken() {\n  return useQuery('access_token', getAccessToken);\n}\n\n/**\n * React hook to get the user id for a given access token.\n */\nexport function useUserId(token) {\n  return useQuery([token, false, 'user_id'], validateToken, { enabled: token });\n}\n\n/**\n * Data loader for an access token.\n *\n * @return {Promise<null|string>}\n */\nexport async function getAccessToken() {\n  // try to fetch a token from storage.\n  let token = localStorage.getItem('token');\n\n  // If there is no stored token, check if we just came back from authorization.\n  if (token === null) {\n    token = getAccessTokenFromUrl();\n\n    // If we don't have a stored token and this was not an auth request then\n    // we don't have a token.\n    if (token === null) {\n      return null;\n    }\n\n    // In case a token was found in the URL we must store it.\n    localStorage.setItem('token', token);\n  }\n\n  // If a token is not valid then we remove it from storage and we're done.\n  const user_id = await validateToken(token);\n  if (user_id === null) {\n    localStorage.removeItem('token');\n    return null;\n  }\n\n  return token;\n}\n\n/**\n * Returns a URL used to authorize the application for the user.\n *\n * @return {string}\n */\nexport function getAuthorizeUrl() {\n  return `https://id.twitch.tv/oauth2/authorize?client_id=${client_id}&redirect_uri=${encodeURIComponent(redirect_uri)}&response_type=token&scope=${scope.join(' ')}`;\n}\n\n/**\n * Validates an access token with Twitch.\n *\n * @param token\n *   The token to validate.\n * @param {boolean} force\n *   Allows re-validation to be forced.\n * @return {Promise<{}|null>}\n *   The promise resolves to true when the token is valid or false when the\n *   token is invalid.\n */\nasync function validateToken(token, force = false) {\n  // A token must be validated at least once per hour. For new tokens we must\n  // also perform initial validation to fetch the user id of the authenticated\n  // user.\n  const validation_time = parseInt(localStorage.getItem('validation_time') ?? 0, 10);\n  const user_id = localStorage.getItem('user_id');\n  const user_name = localStorage.getItem('user_name');\n\n  // If we have recently validated and we have a user_id then we're done.\n  if (!force && validation_time > (Date.now() - (60 * 60 * 1000)) && user_id !== null) {\n    return { user_id, user_name };\n  }\n\n  const response = await fetch(\"https://id.twitch.tv/oauth2/validate\", {\n    headers: {\n      Authorization: `OAuth ${token}`,\n    },\n  });\n\n  if (!response.ok) {\n    return null;\n  }\n\n  try {\n    const data = await response.json();\n    let user_id = typeof data[\"user_id\"] !== \"undefined\" ? data[\"user_id\"] : null;\n    let user_name = typeof data[\"login\"] !== \"undefined\" ? data[\"login\"] : null;\n\n    localStorage.setItem('user_id', user_id);\n    localStorage.setItem('user_name', user_name);\n    localStorage.setItem('validation_time', Date.now().toString());\n    return user_id === null || user_name === null ? null : { user_id, user_name };\n  }\n  // In case of invalid JSON we return null.\n  catch (e) {\n    return null;\n  }\n}\n\n/**\n * Finds an access token in the URL if there is one.\n *\n * Used to check if the current page is being loaded in response to an\n * authentication request.\n *\n * @return {string|null}\n *   The access token from the URL or null if none was found.\n */\nfunction getAccessTokenFromUrl() {\n  const hash = window.location.hash;\n  // The hash includes the # so we need at least something beyond that.\n  if (hash.length <= 1) {\n    return null;\n  }\n\n  const data = parseQuery(hash.substr(1));\n\n  if (typeof data['access_token'] === \"undefined\" || typeof data['token_type'] === \"undefined\" || data[\"token_type\"] !== \"bearer\") {\n    return null;\n  }\n\n  // Remove the access token from the hash so the link is safe to share.\n  window.location.hash = '';\n\n  return data[\"access_token\"];\n}\n\n/**\n * Parses a query string and returns its components as objects.\n *\n * @param queryString\n *   The query string to parse.\n * @return {{}}\n *   An object containing the found parts.\n */\nfunction parseQuery(queryString) {\n  let query = {};\n  const pairs = (queryString[0] === '?' ? queryString.substr(1) : queryString).split('&');\n\n  for (let i = 0, j = pairs.length; i < j; i++) {\n    const pair = pairs[i].split('=');\n    query[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1] || '');\n  }\n\n  return query;\n}","import React from \"react\";\nimport './Anonymous.css'\nimport {getAuthorizeUrl} from \"../auth\";\n\nfunction Anonymous() {\n  const authLink = getAuthorizeUrl();\n\n  return (\n    <main className={\"Anonymous\"}>\n      <p>You must authenticate with Twitch to use this tool.</p>\n      <p>\n        The tool will request the following permissions:\n        <ul>\n          {/*<li>Access to your follow list <br/> <span className={\"i\"}>required to let you select the channels you're a moderator in.</span></li>*/}\n          <li>Read and Write chat messages <br /> <span className={\"i\"}>required to be able to issue commands such as ban to Twitch.</span></li>\n          <li>Perform moderation tasks on your behalf <br /> <span className={\"i\"}>required to automatically ban users in the channel you're a moderator in.</span></li>\n        </ul>\n      </p>\n      <p className={\"center\"}>\n        <a href={authLink} className={\"btn btn-primary\"}>Authenticate</a>\n      </p>\n\n    </main>\n  );\n}\n\nexport default Anonymous;","import {useQuery} from \"react-query\";\nimport {client_id} from \"../config\";\n\n/**\n * Retrieves the username for the user.\n *\n * @param {string} access_token\n *   A valid access token.\n * @param {int} user_id\n *   The user to fetch follows for.\n * @return {QueryResult<unknown, unknown>}\n */\nexport function useUsername(access_token, user_id) {\n  return useQuery(['helix/users/follows', access_token, { from_id: user_id }], twitchApi, { staleTime: 0 });\n}\n\n/**\n * Loads the channels a user follows using React query.\n *\n * @param {string} access_token\n *   A valid access token.\n * @param {int} user_id\n *   The user to fetch follows for.\n * @param {string} user_name\n *   The name of the user to fetch follows for. Injected into the results.\n * @return {QueryResult<unknown, unknown>}\n */\nexport function useFollows(access_token, user_id, user_name) {\n  let { isLoading, isError, data, error } = useQuery(['helix/users/follows', access_token, { from_id: user_id }], twitchApi, { staleTime: 10 * 60 * 1000 /* ms */});\n  // If we've done the loading, inject the user themselves as a follow so that\n  // they show up everywhere.\n  if (!isLoading && !isError) {\n    data = {\n      ...data,\n      data: [...data.data, { followed_at: \"2020-01-01T00:00:01Z\", from_id: user_id, from_name: user_name, to_id: user_id, to_name: user_name }],\n    }\n  }\n\n  return { isLoading, isError, data, error };\n}\n\n/**\n * Request function for Twitch API that can be used by React Query.\n *\n * @param endpoint\n * @param access_token\n * @param query\n * @return {Promise<any>}\n */\nasync function twitchApi(endpoint, access_token = null, query = {}) {\n  let url = new URL(endpoint, \"https://api.twitch.tv/\");\n  url.search = (new URLSearchParams(query)).toString();\n  let headers = {\n    \"Client-Id\": client_id,\n  };\n\n  if (access_token !== null) {\n    headers[\"Authorization\"] = `Bearer ${access_token}`;\n  }\n\n  const result = await fetch(url.toString(), { headers });\n\n  const data = await result.json();\n\n  if (typeof data.status !== \"undefined\" && (data.status < 200 || data.status > 300)) {\n    throw data;\n  }\n\n  return data;\n}\n\n\n","import React, {useEffect, useState} from \"react\";\n\n// Convert a username into a valid channel name.\nfunction toChannel(str) {\n  const channel = (str ? str : \"\").toLowerCase();\n  return channel[0] === \"#\" ? channel : \"#\" + channel;\n}\n\nfunction BanForm({ chatClient, follows, user_name }) {\n  // Check form state.\n  const [selected, updateSelected] = useState(() => follows.reduce((a, f) => ({...a, [f.to_name]: false }), {}),[follows]);\n  // Check mod state.\n  const [isMod, updateMod] = useState( () => ({length: 0}));\n  // Create event listener for join to track mod state.\n  useEffect(() => {\n    // Show the user we're joining channels.\n    let onJoin = (channel, joinedUser) => {\n      // Ignore other users.\n      if (joinedUser !== user_name) {\n        return;\n      }\n      // Broadcasters aren't considered moderators but they have the right\n      // powers.\n      let weAreMod = chatClient.isMod(channel, user_name) || channel === toChannel(user_name);\n      updateMod(modStatus => ({...modStatus, length: modStatus.length + 1, [channel]: weAreMod}));\n    }\n    chatClient.on(\"join\", onJoin);\n    return () => {\n      chatClient.off(\"join\", onJoin);\n    }\n  }, [chatClient, updateMod, user_name]);\n  // Keep track of the form fields.\n  const [banForm, updateBanForm] = useState({target_user: '', reason: ''});\n  // Keep track of the banning in progress.\n  const [banState, updateBanState] = useState({});\n\n  // The actual callback to ban the user.\n  const banUser = () => {\n    const target = banForm.target_user;\n    const reason = banForm.reason;\n    updateBanForm({target_user: '', reason: ''});\n    const channelsToBanIn = Object.fromEntries(Object.entries(selected).filter(([_,v]) => v).map(([k,_]) => [k, `Banning ${target}...`]));\n    updateBanState(channelsToBanIn);\n    for (const streamer of Object.keys(channelsToBanIn)) {\n      const channel = toChannel(streamer);\n      chatClient.ban(channel, target, reason)\n        .then(() => updateBanState(s => ({...s, [channel]: `Banned ${target}`})))\n        .catch((e) => updateBanState(s => ({...s, [channel]: `Error ${e.message}`})))\n    }\n  }\n\n  const allSelected = Object.entries(selected).filter(([k,_]) => isMod[toChannel(k)]).every(([_,v]) => v);\n  const mod_channel_list = follows.filter(follower => isMod[toChannel(follower.to_name)]);\n  const follower_list = mod_channel_list.map(follower => {\n    return (\n      <tr key={follower.to_id}>\n        <td>\n          <input\n            type={\"checkbox\"}\n            value={follower.to_name}\n            checked={selected[follower.to_name] ?? false}\n            onChange={() => updateSelected(selected => ({ ...selected, [follower.to_name]: !selected[follower.to_name] }))} />\n        </td>\n        <td>{follower.to_name}</td>\n        <td>{banState[toChannel(follower.to_name)] ?? ''}</td>\n      </tr>\n    )\n  });\n\n  return (\n    <>\n      <table className={\"table-select\"}>\n        <caption>Select streams to apply ban to</caption>\n        <thead>\n        <tr>\n          <th>\n            <input\n              type={\"checkbox\"}\n              checked={allSelected}\n              onChange={() => updateSelected(Object.fromEntries(mod_channel_list.map(follower => [follower.to_name, !allSelected])))}\n            />\n          </th>\n          <th>Broadcaster</th>\n          <th>Status</th>\n        </tr>\n        </thead>\n        <tbody>\n        {isMod.length < follows.length\n          ? <tr><td colSpan={2}>Finding moderator channels, checked {isMod.length}/{follows.length}</td></tr>\n          : follower_list}\n        </tbody>\n      </table>\n      <p>\n        <label>\n          Username<br/>\n          <input\n            type={\"text\"}\n            required={true}\n            value={banForm.target_user}\n            onChange={(e) => {\n              const target_user = e.target.value;\n              updateBanForm(s => ({...s, target_user }))\n            }}\n          />\n        </label>\n      </p>\n      <p>\n        <label>\n          Reason<br/>\n          <input\n            value={banForm.reason}\n            type={\"text\"}\n            onChange={(e) => {\n              const reason = e.target.value;\n              updateBanForm(s => ({...s, reason }))\n            }}\n          />\n        </label>\n      </p>\n      <p>\n        <button disabled={banForm.target_user.length === 0} onClick={banUser} className={\"btn btn-primary\"}>Ban</button>\n      </p>\n    </>\n  );\n}\n\nexport default BanForm;","import { Client } from 'tmi.js';\n\nlet client = null;\n\n/**\n * React hook that provides the chat client.\n *\n * @param token\n *   A valid access token.\n * @param user_name\n *   The name of the user that's using our tool.\n * @param channels\n *   A list of channels that we should join.\n * @param clientStateUpdate\n *   Callback to be called when the client is ready or an error occurs.\n */\nexport function getChatClient(token, user_name, channels, clientStateUpdate) {\n  // Only if we have all the needed data including a channel list can we create\n  // a client.\n  if (client === null && token !== null && user_name !== null && channels.length !== 0) {\n    client = createChatClient(token, user_name, channels);\n    client.connect()\n      .then(() => {\n        clientStateUpdate({ error: null, client })\n      })\n      .catch((error) => {\n        clientStateUpdate({ error, client: null })\n      });\n  }\n}\n\nfunction createChatClient(token, user_name, channels) {\n  let client = new Client({\n    options: { debug: process.env.NODE_ENV === \"development\" },\n    connection: {\n      // Don't automatically reconnect as this case state change loops in\n      // React.\n      reconnect: false,\n      secure: true,\n    },\n    identity: {\n      username: user_name,\n      password: `oauth:${token}`,\n    },\n    // Always include the user themselves in the channel list.\n    channels: [...channels, user_name],\n    logger: {\n      info: () => null,\n      warn: console.warn,\n      error: console.error,\n    }\n  });\n\n  return client;\n}","import React, {useEffect, useRef, useState} from \"react\";\nimport {useFollows} from \"../api\";\nimport \"./Authenticated.css\";\nimport BanForm from \"../components/BanForm\";\nimport {getChatClient} from \"../chat\";\n\nfunction Authenticated({ token, user_id, user_name }) {\n  const { isLoading, isError, data, error } = useFollows(token, user_id, user_name);\n  const [{ error: chatError, client }, updateChatState] = useState({ error: null, client: null });\n  const clientCleanup = useRef(null);\n  clientCleanup.current = client;\n  useEffect(() => {\n    return () => {\n      if (clientCleanup.current !== null) {\n        clientCleanup.current.disconnect();\n        clientCleanup.current = null;\n      }\n    }\n  }, [clientCleanup]);\n\n  if (isLoading) {\n    return <p>Loading follower list.....</p>;\n  }\n\n  if (isError) {\n    return <p>Error loading follower list: {error.message}</p>;\n  }\n\n  // This is slightly hacky but only triggers a state update the first time.\n  getChatClient(token, user_name, data.data.map(f => f.to_name), updateChatState);\n\n  const loggedInAs = <p>Logged in as: {user_name}</p>;\n\n  if (chatError === null && client === null) {\n    return (\n      <>\n        {loggedInAs}\n        <p>Connecting to chatserver....</p>\n      </>\n    );\n  }\n\n  if (chatError !== null) {\n    return (\n      <>\n        {loggedInAs}\n        <p>Error connecting to chatserver: {chatError.message}</p>\n      </>\n    );\n  }\n\n  return (\n    <>\n      {loggedInAs}\n      <BanForm chatClient={client} follows={data.data} user_name={user_name} />\n    </>\n  );\n}\n\nexport default Authenticated;","import React from 'react';\nimport {useAuthState} from \"./auth\";\nimport Anonymous from \"./screens/Anonymous\";\nimport Authenticated from \"./screens/Authenticated\";\n\nfunction Router() {\n  const { isLoading, isError, data: { user, token }, error } = useAuthState();\n\n  if (isLoading) {\n    return <p>Loading...</p>;\n  }\n\n  if (isError) {\n    return <p>Unexpected error while authenticating: {error.message}</p>;\n  }\n\n  if (user === null) {\n    return <Anonymous />;\n  }\n\n  return (\n    <main className={\"Authenticated\"}>\n      <Authenticated user_id={user.user_id} user_name={user.user_name} token={token} />\n    </main>\n  );\n}\n\nexport default Router;\n","import React from 'react';\nimport \"./Footer.css\";\n\nfunction Footer() {\n  return (\n    <footer className={\"Footer\"}>\n      <span>&copy; Copyright 2020 - Kingdutch</span>\n      <span><a href={\"https://github.com/Kingdutch/twitch-ban-assist/\"}>Open Source on GitHub</a></span>\n    </footer>\n  )\n}\n\nexport default Footer;\n","import React from 'react';\nimport Router from \"./Router\";\nimport Footer from \"./components/Footer\";\n\nfunction App() {\n  return (\n    <>\n      <Router />\n      <Footer />\n    </>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { QueryCache, ReactQueryCacheProvider } from 'react-query';\nimport './index.css';\nimport './tokens.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nconst queryCache = new QueryCache();\n\n// Chat joins can cause a lot of event listeners to be added so we disable\n// that error.\nif (typeof process.setMaxListeners !== \"undefined\") {\n  process.setMaxListeners(0);\n}\n\nReactDOM.render(\n  <React.StrictMode>\n    <ReactQueryCacheProvider queryCache={queryCache}>\n      <App />\n    </ReactQueryCacheProvider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}