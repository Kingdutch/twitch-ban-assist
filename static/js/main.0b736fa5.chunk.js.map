{"version":3,"sources":["serviceWorker.js","config.js","auth/index.js","screens/Anonymous.js","api/index.js","components/BanForm.js","chat/index.js","screens/Authenticated.js","Router.js","components/Footer.js","App.js","index.js"],"names":["Boolean","window","location","hostname","match","unregister","navigator","serviceWorker","ready","then","registration","catch","error","console","message","client_id","scope","useAuthState","useQuery","getAccessToken","isLoadingToken","isLoading","isErrorToken","isError","token","data","errorToken","validateToken","enabled","useUserId","isLoadingId","isErrorId","user","errorId","a","localStorage","getItem","getAccessTokenFromUrl","setItem","removeItem","force","validation_time","parseInt","user_id","user_name","Date","now","fetch","headers","Authorization","response","ok","json","toString","hash","length","queryString","query","pairs","substr","split","i","j","pair","decodeURIComponent","parseQuery","Anonymous","authLink","encodeURIComponent","join","className","href","getMods","result","Error","statusText","channels","map","c","name","toChannel","str","channel","toLowerCase","BanForm","chatClient","channelLookup","useMemo","Object","fromEntries","useState","selected","updateSelected","useEffect","onJoin","joinedUser","on","off","target_user","reason","banForm","updateBanForm","banState","updateBanState","allSelected","entries","every","channel_list","hasJoined","key","type","value","disabled","checked","onChange","k","required","e","target","s","onClick","channelsToBanIn","filter","ban","keys","client","getChatClient","clientStateUpdate","Client","options","debug","process","connection","reconnect","secure","identity","username","password","logger","info","warn","createChatClient","connect","Authenticated","staleTime","useMods","mod_channels","chatError","updateChatState","clientCleanup","useRef","current","disconnect","loggedInAs","rel","Router","Footer","App","queryCache","QueryCache","setMaxListeners","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.0b736fa5.chunk.js","sourcesContent":["// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","export const client_id = \"ok7ldffjfrdafeme3x5jfob7rxhmlv\";\nexport const redirect_uri = process.env.NODE_ENV === \"production\" ? \"https://kingdutch.github.io/twitch-ban-assist/\" : \"http://localhost:3000/twitch-ban-assist/\";\nexport const scope = [\n  'chat:read',\n  'chat:edit',\n  'channel:moderate',\n];\n","import { useQuery } from 'react-query';\nimport { client_id, redirect_uri, scope } from '../config';\n\n/**\n * React hook to get the auth state for a user.\n *\n * @return {{isLoading: boolean, isError: boolean, data: {user_id: string,\n *   token: string}, error: unknown}}\n */\nexport function useAuthState() {\n  const { isLoading: isLoadingToken, isError: isErrorToken, data: token, error: errorToken } = useAccessToken();\n  const { isLoading: isLoadingId, isError: isErrorId, data: user, error: errorId } = useUserId(token);\n  return {\n    isLoading: isLoadingToken || isLoadingId,\n    isError: isErrorToken || isErrorId,\n    data: { token, user: typeof user === \"undefined\" ? null : user },\n    error: errorToken || errorId,\n  };\n}\n\n/**\n * React hook to get the access token using react-query.\n */\nexport function useAccessToken() {\n  return useQuery('access_token', getAccessToken);\n}\n\n/**\n * React hook to get the user id for a given access token.\n */\nexport function useUserId(token) {\n  return useQuery([token, false, 'user_id'], validateToken, { enabled: token });\n}\n\n/**\n * Data loader for an access token.\n *\n * @return {Promise<null|string>}\n */\nexport async function getAccessToken() {\n  // try to fetch a token from storage.\n  let token = localStorage.getItem('token');\n\n  // If there is no stored token, check if we just came back from authorization.\n  if (token === null) {\n    token = getAccessTokenFromUrl();\n\n    // If we don't have a stored token and this was not an auth request then\n    // we don't have a token.\n    if (token === null) {\n      return null;\n    }\n\n    // In case a token was found in the URL we must store it.\n    localStorage.setItem('token', token);\n  }\n\n  // If a token is not valid then we remove it from storage and we're done.\n  const user_id = await validateToken(token);\n  if (user_id === null) {\n    localStorage.removeItem('token');\n    return null;\n  }\n\n  return token;\n}\n\n/**\n * Returns a URL used to authorize the application for the user.\n *\n * @return {string}\n */\nexport function getAuthorizeUrl() {\n  return `https://id.twitch.tv/oauth2/authorize?client_id=${client_id}&redirect_uri=${encodeURIComponent(redirect_uri)}&response_type=token&scope=${scope.join(' ')}`;\n}\n\n/**\n * Validates an access token with Twitch.\n *\n * @param token\n *   The token to validate.\n * @param {boolean} force\n *   Allows re-validation to be forced.\n * @return {Promise<{}|null>}\n *   The promise resolves to true when the token is valid or false when the\n *   token is invalid.\n */\nasync function validateToken(token, force = false) {\n  // A token must be validated at least once per hour. For new tokens we must\n  // also perform initial validation to fetch the user id of the authenticated\n  // user.\n  const validation_time = parseInt(localStorage.getItem('validation_time') ?? 0, 10);\n  const user_id = localStorage.getItem('user_id');\n  const user_name = localStorage.getItem('user_name');\n\n  // If we have recently validated and we have a user_id then we're done.\n  if (!force && validation_time > (Date.now() - (60 * 60 * 1000)) && user_id !== null) {\n    return { user_id, user_name };\n  }\n\n  const response = await fetch(\"https://id.twitch.tv/oauth2/validate\", {\n    headers: {\n      Authorization: `OAuth ${token}`,\n    },\n  });\n\n  if (!response.ok) {\n    return null;\n  }\n\n  try {\n    const data = await response.json();\n    let user_id = typeof data[\"user_id\"] !== \"undefined\" ? data[\"user_id\"] : null;\n    let user_name = typeof data[\"login\"] !== \"undefined\" ? data[\"login\"] : null;\n\n    localStorage.setItem('user_id', user_id);\n    localStorage.setItem('user_name', user_name);\n    localStorage.setItem('validation_time', Date.now().toString());\n    return user_id === null || user_name === null ? null : { user_id, user_name };\n  }\n  // In case of invalid JSON we return null.\n  catch (e) {\n    return null;\n  }\n}\n\n/**\n * Finds an access token in the URL if there is one.\n *\n * Used to check if the current page is being loaded in response to an\n * authentication request.\n *\n * @return {string|null}\n *   The access token from the URL or null if none was found.\n */\nfunction getAccessTokenFromUrl() {\n  const hash = window.location.hash;\n  // The hash includes the # so we need at least something beyond that.\n  if (hash.length <= 1) {\n    return null;\n  }\n\n  const data = parseQuery(hash.substr(1));\n\n  if (typeof data['access_token'] === \"undefined\" || typeof data['token_type'] === \"undefined\" || data[\"token_type\"] !== \"bearer\") {\n    return null;\n  }\n\n  // Remove the access token from the hash so the link is safe to share.\n  window.location.hash = '';\n\n  return data[\"access_token\"];\n}\n\n/**\n * Parses a query string and returns its components as objects.\n *\n * @param queryString\n *   The query string to parse.\n * @return {{}}\n *   An object containing the found parts.\n */\nfunction parseQuery(queryString) {\n  let query = {};\n  const pairs = (queryString[0] === '?' ? queryString.substr(1) : queryString).split('&');\n\n  for (let i = 0, j = pairs.length; i < j; i++) {\n    const pair = pairs[i].split('=');\n    query[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1] || '');\n  }\n\n  return query;\n}","import React from \"react\";\nimport './Anonymous.css'\nimport {getAuthorizeUrl} from \"../auth\";\n\nfunction Anonymous() {\n  const authLink = getAuthorizeUrl();\n\n  return (\n    <main className={\"Anonymous\"}>\n      <p>You must authenticate with Twitch to use this tool.</p>\n      <p>\n        The tool will request the following permissions:\n        <ul>\n          {/*<li>Access to your follow list <br/> <span className={\"i\"}>required to let you select the channels you're a moderator in.</span></li>*/}\n          <li>Read and Write chat messages <br /> <span className={\"i\"}>required to be able to issue commands such as ban to Twitch.</span></li>\n          <li>Perform moderation tasks on your behalf <br /> <span className={\"i\"}>required to automatically ban users in the channel you're a moderator in.</span></li>\n        </ul>\n      </p>\n      <p className={\"center\"}>\n        <a href={authLink} className={\"btn btn-primary\"}>Authenticate</a>\n      </p>\n\n    </main>\n  );\n}\n\nexport default Anonymous;","import {useQuery} from \"react-query\";\nimport {client_id} from \"../config\";\n\n/**\n * Retrieves the username for the user.\n *\n * @param {string} access_token\n *   A valid access token.\n * @param {int} user_id\n *   The user to fetch follows for.\n * @return {QueryResult<unknown, unknown>}\n */\nexport function useUsername(access_token, user_id) {\n  return useQuery(['helix/users/follows', access_token, { from_id: user_id }], twitchApi, { staleTime: 0 });\n}\n\n/**\n * Loads the channels a user is a moderator in using React query.\n *\n * @param {string} user_name\n *   The name of the user to fetch follows for. Injected into the results.\n * @return {QueryResult<unknown, unknown>}\n */\nexport function useMods(user_name) {\n  let { isLoading, isError, data, error } = useQuery([user_name, 'user_follows'], getMods, { staleTime: 12 * 60 * 60 * 1000 /* 12 hours in ms */});\n  // If we've done the loading, inject the user themselves as a channel so that\n  // they show up everywhere. Broadcasters are not marked as mods by default.\n  if (!isLoading && !isError) {\n    data = [...data, user_name];\n  }\n\n  return { isLoading, isError, data, error };\n}\n\n/**\n * Request function for Twitch API that can be used by React Query.\n *\n * @param endpoint\n * @param access_token\n * @param query\n * @return {Promise<any>}\n */\nasync function twitchApi(endpoint, access_token = null, query = {}) {\n  let url = new URL(endpoint, \"https://api.twitch.tv/\");\n  url.search = (new URLSearchParams(query)).toString();\n  let headers = {\n    \"Client-Id\": client_id,\n  };\n\n  if (access_token !== null) {\n    headers[\"Authorization\"] = `Bearer ${access_token}`;\n  }\n\n  const result = await fetch(url.toString(), { headers });\n\n  const data = await result.json();\n\n  if (typeof data.status !== \"undefined\" && (data.status < 200 || data.status > 300)) {\n    throw data;\n  }\n\n  return data;\n}\n\n/**\n * Fetches the channels a user is a moderator of from ModLookup.\n * @param user_name\n *   The user to find moderator channels for.\n * @return {Promise<*|*[]>}\n *   A promise that resolves to a list of channels the user is a moderator for.\n */\nasync function getMods(user_name) {\n  const result = await fetch(`https://modlookup.3v.fi/api/user-v3/${user_name}?limit=10000`);\n\n  if (!result.ok) {\n    throw new Error(result.statusText);\n  }\n\n  const data = await result.json();\n  return (data.channels || []).map(c => c.name);\n}\n","import React, {useEffect, useMemo, useState} from \"react\";\n\n// Convert a username into a valid channel name.\nfunction toChannel(str) {\n  const channel = (str ? str : \"\").toLowerCase();\n  return channel[0] === \"#\" ? channel : \"#\" + channel;\n}\n\nfunction BanForm({ chatClient, channels, user_name }) {\n  // Create a lookup table for IRC channel to Twitch channel names.\n  const channelLookup = useMemo(() => Object.fromEntries(channels.map(c => [toChannel(c), c])), [channels]);\n  // Check form state.\n  const [selected, updateSelected] = useState({});\n  // Create event listener for join to track mod state.\n  useEffect(() => {\n    // Show the user we're joining channels.\n    let onJoin = (channel, joinedUser) => {\n      // Ignore other users.\n      if (joinedUser !== user_name) {\n        return;\n      }\n      // Add the channel to our list of possible channels to select.\n      updateSelected(selected => ({...selected, [channelLookup[channel]]: false}));\n    }\n    chatClient.on(\"join\", onJoin);\n    return () => {\n      chatClient.off(\"join\", onJoin);\n    }\n  }, [chatClient, updateSelected, user_name, channelLookup]);\n  // Keep track of the form fields.\n  const [banForm, updateBanForm] = useState({target_user: '', reason: ''});\n  // Keep track of the banning in progress.\n  const [banState, updateBanState] = useState({});\n\n  // The actual callback to ban the user.\n  const banUser = () => {\n    const target = banForm.target_user;\n    const reason = banForm.reason;\n    updateBanForm({target_user: '', reason: ''});\n    const channelsToBanIn = Object.fromEntries(Object.entries(selected).filter(([_,v]) => v).map(([k,_]) => [k, `Banning ${target}...`]));\n    updateBanState(channelsToBanIn);\n    for (const streamer of Object.keys(channelsToBanIn)) {\n      const channel = toChannel(streamer);\n      chatClient.ban(channel, target, reason)\n        .then(() => updateBanState(s => ({...s, [channel]: `Banned ${target}`})))\n        .catch((e) => updateBanState(s => ({...s, [channel]: `Error ${e}`})))\n    }\n  }\n\n  const allSelected = Object.entries(selected).every(([_,v]) => v);\n  const channel_list = channels.map(channel => {\n    const hasJoined = typeof selected[channel] !== \"undefined\";\n    return (\n      <tr key={channel}>\n        <td>\n          <input\n            type={\"checkbox\"}\n            value={channel}\n            disabled={!hasJoined}\n            checked={selected[channel] ?? false}\n            onChange={() => updateSelected(selected => ({ ...selected, [channel]: !selected[channel] }))} />\n        </td>\n        <td>{channel}</td>\n        <td>{hasJoined ? (banState[toChannel(channel)] ?? '') : \"Joining channel...\"}</td>\n      </tr>\n    )\n  });\n\n  return (\n    <>\n      <table className={\"table-select\"}>\n        <caption>Select streams to apply ban to</caption>\n        <thead>\n        <tr>\n          <th>\n            <input\n              type={\"checkbox\"}\n              checked={allSelected}\n              onChange={() => updateSelected(selected => Object.fromEntries(Object.entries(selected).map(([k,_]) => [k, !allSelected])))}\n            />\n          </th>\n          <th>Broadcaster</th>\n          <th>Status</th>\n        </tr>\n        </thead>\n        <tbody>\n        {channel_list}\n        </tbody>\n      </table>\n      <p>\n        <label>\n          Username<br/>\n          <input\n            type={\"text\"}\n            required={true}\n            value={banForm.target_user}\n            onChange={(e) => {\n              const target_user = e.target.value;\n              updateBanForm(s => ({...s, target_user }))\n            }}\n          />\n        </label>\n      </p>\n      <p>\n        <label>\n          Reason<br/>\n          <input\n            value={banForm.reason}\n            type={\"text\"}\n            onChange={(e) => {\n              const reason = e.target.value;\n              updateBanForm(s => ({...s, reason }))\n            }}\n          />\n        </label>\n      </p>\n      <p>\n        <button disabled={banForm.target_user.length === 0} onClick={banUser} className={\"btn btn-primary\"}>Ban</button>\n      </p>\n    </>\n  );\n}\n\nexport default BanForm;","import { Client } from 'tmi.js';\n\nlet client = null;\n\n/**\n * React hook that provides the chat client.\n *\n * @param token\n *   A valid access token.\n * @param user_name\n *   The name of the user that's using our tool.\n * @param channels\n *   A list of channels that we should join.\n * @param clientStateUpdate\n *   Callback to be called when the client is ready or an error occurs.\n */\nexport function getChatClient(token, user_name, channels, clientStateUpdate) {\n  // Only if we have all the needed data including a channel list can we create\n  // a client.\n  if (client === null && token !== null && user_name !== null && channels.length !== 0) {\n    client = createChatClient(token, user_name, channels);\n    client.connect()\n      .then(() => {\n        clientStateUpdate({ error: null, client })\n      })\n      .catch((error) => {\n        clientStateUpdate({ error, client: null })\n      });\n  }\n}\n\nfunction createChatClient(token, user_name, channels) {\n  return new Client({\n    options: { debug: process.env.NODE_ENV === \"development\" },\n    connection: {\n      // Don't automatically reconnect as this case state change loops in\n      // React.\n      reconnect: false,\n      secure: true,\n    },\n    identity: {\n      username: user_name,\n      password: `oauth:${token}`,\n    },\n    channels,\n    logger: {\n      info: () => null,\n      warn: console.warn,\n      error: console.error,\n    }\n  });\n}","import React, {useEffect, useRef, useState} from \"react\";\nimport {useMods} from \"../api\";\nimport \"./Authenticated.css\";\nimport BanForm from \"../components/BanForm\";\nimport {getChatClient} from \"../chat\";\n\nfunction Authenticated({ token, user_name }) {\n  const { isLoading, isError, data: mod_channels, error } = useMods(user_name);\n  const [{ error: chatError, client }, updateChatState] = useState({ error: null, client: null });\n  const clientCleanup = useRef(null);\n  clientCleanup.current = client;\n  useEffect(() => {\n    return () => {\n      if (clientCleanup.current !== null) {\n        clientCleanup.current.disconnect();\n        clientCleanup.current = null;\n      }\n    }\n  }, [clientCleanup]);\n\n  if (isLoading) {\n    return <p>Loading follower list.....</p>;\n  }\n\n  if (isError) {\n    return <p>Error loading follower list: {error.message}</p>;\n  }\n\n  // This is slightly hacky but only triggers a state update the first time.\n  getChatClient(token, user_name, mod_channels, updateChatState);\n\n  const loggedInAs = <p>Logged in as: {user_name}</p>;\n\n  if (chatError === null && client === null) {\n    return (\n      <>\n        {loggedInAs}\n        <p>Connecting to chatserver....</p>\n      </>\n    );\n  }\n\n  if (chatError !== null) {\n    return (\n      <>\n        {loggedInAs}\n        <p>Error connecting to chatserver: {chatError.message}</p>\n      </>\n    );\n  }\n\n  return (\n    <>\n      <div className={\"banner\"}>\n        This tool uses the <a href=\"https://modlookup.3v.fi/\" target=\"_blank\" rel=\"noopener noreferrer\">Mod Lookup</a> tool\n        which updates once a day. If you were recently modded in a channel\n        it may take some time to show up.\n      </div>\n      {loggedInAs}\n      <BanForm chatClient={client} channels={mod_channels} user_name={user_name} />\n    </>\n  );\n}\n\nexport default Authenticated;","import React from 'react';\nimport {useAuthState} from \"./auth\";\nimport Anonymous from \"./screens/Anonymous\";\nimport Authenticated from \"./screens/Authenticated\";\n\nfunction Router() {\n  const { isLoading, isError, data: { user, token }, error } = useAuthState();\n\n  if (isLoading) {\n    return <p>Loading...</p>;\n  }\n\n  if (isError) {\n    return <p>Unexpected error while authenticating: {error.message}</p>;\n  }\n\n  if (user === null) {\n    return <Anonymous />;\n  }\n\n  return (\n    <main className={\"Authenticated\"}>\n      <Authenticated user_id={user.user_id} user_name={user.user_name} token={token} />\n    </main>\n  );\n}\n\nexport default Router;\n","import React from 'react';\nimport \"./Footer.css\";\n\nfunction Footer() {\n  return (\n    <footer className={\"Footer\"}>\n      <span>&copy; Copyright 2020 - Kingdutch</span>\n      <span><a href={\"https://github.com/Kingdutch/twitch-ban-assist/\"}>Open Source on GitHub</a></span>\n    </footer>\n  )\n}\n\nexport default Footer;\n","import React from 'react';\nimport Router from \"./Router\";\nimport Footer from \"./components/Footer\";\n\nfunction App() {\n  return (\n    <>\n      <Router />\n      <Footer />\n    </>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { QueryCache, ReactQueryCacheProvider } from 'react-query';\nimport './index.css';\nimport './tokens.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nconst queryCache = new QueryCache();\n\n// Chat joins can cause a lot of event listeners to be added so we disable\n// that error.\nif (typeof process.setMaxListeners !== \"undefined\") {\n  process.setMaxListeners(0);\n}\n\nReactDOM.render(\n  <React.StrictMode>\n    <ReactQueryCacheProvider queryCache={queryCache}>\n      <App />\n    </ReactQueryCacheProvider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}